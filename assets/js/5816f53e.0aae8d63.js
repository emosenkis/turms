"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8491],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return h}});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(r),h=a,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||s;return r?n.createElement(d,i(i({ref:t},p),{},{components:r})):n.createElement(d,i({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var c=2;c<s;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},58224:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return m}});var n=r(87462),a=r(63366),s=(r(67294),r(3905)),i=["components"],o={},l="Strawberry (Schema first)",c={unversionedId:"usecases/schema/strawberry",id:"usecases/schema/strawberry",title:"Strawberry (Schema first)",description:"The strawberry graphql library is a powerful resolver (implementation) first",source:"@site/docs/usecases/schema/strawberry.md",sourceDirName:"usecases/schema",slug:"/usecases/schema/strawberry",permalink:"/turms/docs/usecases/schema/strawberry",editUrl:"https://github.com/jhnnsrs/turms/edit/master/website/docs/usecases/schema/strawberry.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Document Code Generation",permalink:"/turms/docs/usecases/documents/client"},next:{title:"General design",permalink:"/turms/docs/design/intro"}},p=[{value:"Example",id:"example",children:[],level:2},{value:"Example Project",id:"example-project",children:[],level:2}],u={toc:p};function m(e){var t=e.components,r=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"strawberry-schema-first"},"Strawberry (Schema first)"),(0,s.kt)("p",null,"The strawberry graphql library is a powerful resolver (implementation) first\ngraphql api library that tightly intergrates with python dataclasses. Through\nimplementing the resolvers strawberry is then able to autogenerate a graphql\nschema for you."),(0,s.kt)("p",null,"Contrasting to a resolver first approach, A schema-first approach is a design methodology for building GraphQL APIs in which the schema is the starting point for the development process. In this approach, the schema is used to define the structure of the data that is available through the API, including the types of data that can be queried, the fields and arguments that are available for each type, and any relationships between types."),(0,s.kt)("p",null,"Once the schema is defined (in the graphql DSL) the implementation of the API can be built to support the schema. This includes defining resolvers for each field in the schema, which are responsible for retrieving the data for that field from the underlying data store."),(0,s.kt)("p",null,"Turms in this use-case provides the toolbox for generating and migrating changes from your graphql SDL schema to your strawberry python code."),(0,s.kt)("h2",{id:"example"},"Example"),(0,s.kt)("p",null,"Consider the following schema that you (and your team have designed)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-gql"},'type Beast {\n  "ID of beast (taken from binomial initial)"\n  id: ID\n  "number of legs beast has"\n  legs: Int\n  "a beast\'s name in Latin"\n  binomial: String\n  "a beast\'s name to you and I"\n  commonName: String\n  "taxonomy grouping"\n  taxClass: String\n  "a beast\'s prey"\n  eats: [Beast]\n  "a beast\'s predators"\n  isEatenBy: [Beast]\n}\n\ntype Query {\n  """\n  get all the beasts on the server\n  """\n  beasts: [Beast]\n  beast(id: ID!): Beast!\n  calledBy(commonName: String!): [Beast]!\n}\n\ntype Mutation {\n  """\n  create a massive beast on the server\n  """\n  createBeast(\n    id: ID!\n    legs: Int!\n    binomial: String!\n    commonName: String!\n    taxClass: String!\n    eats: [ID]\n  ): Beast!\n}\n\ntype Subscription {\n  watchBeast(id: ID!): Beast\n}\n')),(0,s.kt)("p",null,"Translating this to a strawberry resolver first approach, is now as simple creating a graphq-config file\nin the directory using these settings"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"projects:\n  default:\n    schema: beasts.graphql\n    extensions:\n      turms:\n        skip_forwards: true\n        out_dir: api\n        stylers:\n          - type: turms.stylers.capitalize.CapitalizeStyler\n          - type: turms.stylers.snake_case.SnakeCaseStyler\n        plugins:\n          - type: turms.plugins.strawberry.StrawberryPlugin # generates a strawberry schema\n        processors:\n          - type: turms.processors.disclaimer.DisclaimerProcessor\n          - type: turms.processors.black.BlackProcessor\n          - type: turms.processors.isort.IsortProcessor\n          - type: turms.processors.merge.MergeProcessor # merges the formated schema with already defined functions\n        scalar_definitions:\n          uuid: str\n          _Any: typing.Any\n")),(0,s.kt)("p",null,"When running ",(0,s.kt)("inlineCode",{parentName:"p"},"turms gen")),(0,s.kt)("p",null,"This will now generate"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-python"},'\n""" This file was code generated by turms. If you want to change the contents of this file, you should make sure to add the MergeProcessor to your config will keep your changes when you re-run turms)."""\n\nfrom enum import Enum\nfrom typing import AsyncGenerator, List, Optional\n\nimport strawberry\n\n\n@strawberry.type\nclass Beast:\n    id: Optional[str] = strawberry.field(\n        description="ID of beast (taken from binomial initial)"\n    )\n    legs: Optional[int] = strawberry.field(description="number of legs beast has")\n    binomial: Optional[str] = strawberry.field(description="a beast\'s name in Latin")\n    common_name: Optional[str] = strawberry.field(\n        description="a beast\'s name to you and I"\n    )\n    tax_class: Optional[str] = strawberry.field(description="taxonomy grouping")\n    eats: Optional[List[Optional["Beast"]]] = strawberry.field(\n        description="a beast\'s prey"\n    )\n    is_eaten_by: Optional[List[Optional["Beast"]]] = strawberry.field(\n        description="a beast\'s predators"\n    )\n\n\n@strawberry.type\nclass Query:\n    @strawberry.field(description="get all the beasts on the server")\n    def beasts(self) -> Optional[List[Optional[Beast]]]:\n        """get all the beasts on the server"""\n        return None\n\n    @strawberry.field()\n    def beast(self, id: str) -> Beast:\n        return None\n\n    @strawberry.field()\n    def called_by(self, common_name: str) -> List[Optional[Beast]]:\n        return None\n\n\n@strawberry.type\nclass Mutation:\n    @strawberry.mutation(description="create a massive beast on the server")\n    def create_beast(\n        self,\n        id: str,\n        legs: int,\n        binomial: str,\n        common_name: str,\n        tax_class: str,\n        eats: Optional[List[Optional[str]]],\n    ) -> Beast:\n        """create a massive beast on the server"""\n        return None\n\n\n@strawberry.type\nclass Subscription:\n    @strawberry.subscription()\n    async def watch_beast(self, id: str) -> AsyncGenerator[Optional[Beast], None]:\n        return None\n\n')),(0,s.kt)("p",null,"You can now easily add the resolvers into the generated file. With the (at the time) experimental\nMergeProcessor migrations in the schema like new fields or change in arguments, can be easily migrated\nto the python code as function bodies (the resolver part) or other fields that are not schema fields, will\nnot be replaced, but just rerunning"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"turms gen")),(0,s.kt)("h2",{id:"example-project"},"Example Project"),(0,s.kt)("p",null,"In the example project (here)","[https://github.com/jhnnsrs/turms/tree/master/examples/beasts-strawberry]",". We illustrate the necessary configuration to use code generation in a schema first approach."))}m.isMDXComponent=!0}}]);